// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package go_pubsub

import (
	"cloud.google.com/go/pubsub"
	"context"
	"sync"
)

// Ensure, that IPubSubClientMock does implement IPubSubClient.
// If this is not the case, regenerate this file with moq.
var _ IPubSubClient = &IPubSubClientMock{}

// IPubSubClientMock is a mock implementation of IPubSubClient.
//
// 	func TestSomethingThatUsesIPubSubClient(t *testing.T) {
//
// 		// make and configure a mocked IPubSubClient
// 		mockedIPubSubClient := &IPubSubClientMock{
// 			TopicFunc: func(id string) IPubSubTopic {
// 				panic("mock out the Topic method")
// 			},
// 		}
//
// 		// use mockedIPubSubClient in code that requires IPubSubClient
// 		// and then make assertions.
//
// 	}
type IPubSubClientMock struct {
	// TopicFunc mocks the Topic method.
	TopicFunc func(id string) IPubSubTopic

	// calls tracks calls to the methods.
	calls struct {
		// Topic holds details about calls to the Topic method.
		Topic []struct {
			// ID is the id argument value.
			ID string
		}
	}
	lockTopic sync.RWMutex
}

// Topic calls TopicFunc.
func (mock *IPubSubClientMock) Topic(id string) IPubSubTopic {
	if mock.TopicFunc == nil {
		panic("IPubSubClientMock.TopicFunc: method is nil but IPubSubClient.Topic was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: id,
	}
	mock.lockTopic.Lock()
	mock.calls.Topic = append(mock.calls.Topic, callInfo)
	mock.lockTopic.Unlock()
	return mock.TopicFunc(id)
}

// TopicCalls gets all the calls that were made to Topic.
// Check the length with:
//     len(mockedIPubSubClient.TopicCalls())
func (mock *IPubSubClientMock) TopicCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	mock.lockTopic.RLock()
	calls = mock.calls.Topic
	mock.lockTopic.RUnlock()
	return calls
}

// Ensure, that IPubSubTopicMock does implement IPubSubTopic.
// If this is not the case, regenerate this file with moq.
var _ IPubSubTopic = &IPubSubTopicMock{}

// IPubSubTopicMock is a mock implementation of IPubSubTopic.
//
// 	func TestSomethingThatUsesIPubSubTopic(t *testing.T) {
//
// 		// make and configure a mocked IPubSubTopic
// 		mockedIPubSubTopic := &IPubSubTopicMock{
// 			ExistsFunc: func(ctx context.Context) (bool, error) {
// 				panic("mock out the Exists method")
// 			},
// 			PublishFunc: func(ctx context.Context, msg *pubsub.Message) IPubSubPublishResult {
// 				panic("mock out the Publish method")
// 			},
// 		}
//
// 		// use mockedIPubSubTopic in code that requires IPubSubTopic
// 		// and then make assertions.
//
// 	}
type IPubSubTopicMock struct {
	// ExistsFunc mocks the Exists method.
	ExistsFunc func(ctx context.Context) (bool, error)

	// PublishFunc mocks the Publish method.
	PublishFunc func(ctx context.Context, msg *pubsub.Message) IPubSubPublishResult

	// calls tracks calls to the methods.
	calls struct {
		// Exists holds details about calls to the Exists method.
		Exists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Publish holds details about calls to the Publish method.
		Publish []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Msg is the msg argument value.
			Msg *pubsub.Message
		}
	}
	lockExists  sync.RWMutex
	lockPublish sync.RWMutex
}

// Exists calls ExistsFunc.
func (mock *IPubSubTopicMock) Exists(ctx context.Context) (bool, error) {
	if mock.ExistsFunc == nil {
		panic("IPubSubTopicMock.ExistsFunc: method is nil but IPubSubTopic.Exists was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockExists.Lock()
	mock.calls.Exists = append(mock.calls.Exists, callInfo)
	mock.lockExists.Unlock()
	return mock.ExistsFunc(ctx)
}

// ExistsCalls gets all the calls that were made to Exists.
// Check the length with:
//     len(mockedIPubSubTopic.ExistsCalls())
func (mock *IPubSubTopicMock) ExistsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockExists.RLock()
	calls = mock.calls.Exists
	mock.lockExists.RUnlock()
	return calls
}

// Publish calls PublishFunc.
func (mock *IPubSubTopicMock) Publish(ctx context.Context, msg *pubsub.Message) IPubSubPublishResult {
	if mock.PublishFunc == nil {
		panic("IPubSubTopicMock.PublishFunc: method is nil but IPubSubTopic.Publish was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Msg *pubsub.Message
	}{
		Ctx: ctx,
		Msg: msg,
	}
	mock.lockPublish.Lock()
	mock.calls.Publish = append(mock.calls.Publish, callInfo)
	mock.lockPublish.Unlock()
	return mock.PublishFunc(ctx, msg)
}

// PublishCalls gets all the calls that were made to Publish.
// Check the length with:
//     len(mockedIPubSubTopic.PublishCalls())
func (mock *IPubSubTopicMock) PublishCalls() []struct {
	Ctx context.Context
	Msg *pubsub.Message
} {
	var calls []struct {
		Ctx context.Context
		Msg *pubsub.Message
	}
	mock.lockPublish.RLock()
	calls = mock.calls.Publish
	mock.lockPublish.RUnlock()
	return calls
}

// Ensure, that IPubSubPublishResultMock does implement IPubSubPublishResult.
// If this is not the case, regenerate this file with moq.
var _ IPubSubPublishResult = &IPubSubPublishResultMock{}

// IPubSubPublishResultMock is a mock implementation of IPubSubPublishResult.
//
// 	func TestSomethingThatUsesIPubSubPublishResult(t *testing.T) {
//
// 		// make and configure a mocked IPubSubPublishResult
// 		mockedIPubSubPublishResult := &IPubSubPublishResultMock{
// 			GetFunc: func(ctx context.Context) (string, error) {
// 				panic("mock out the Get method")
// 			},
// 		}
//
// 		// use mockedIPubSubPublishResult in code that requires IPubSubPublishResult
// 		// and then make assertions.
//
// 	}
type IPubSubPublishResultMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *IPubSubPublishResultMock) Get(ctx context.Context) (string, error) {
	if mock.GetFunc == nil {
		panic("IPubSubPublishResultMock.GetFunc: method is nil but IPubSubPublishResult.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//     len(mockedIPubSubPublishResult.GetCalls())
func (mock *IPubSubPublishResultMock) GetCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}
